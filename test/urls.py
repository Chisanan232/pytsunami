from smoothcrawler import URL
from datetime import date, timedelta
import pytest
import re


TEST_TARGET_URL = "https://www.google.com"
TEST_TARGET_URL_WITH_INDEX = "https://www.test.com?index={index}"
TEST_TARGET_URL_WITH_DATE = "https://www.google.com?date={date}"
TEST_TARGET_URL_WITH_DATETIME = "https://www.google.com?datetime={datetime}"
TEST_TARGET_URL_WITH_ITERATOR = "https://www.google.com?option={iterator}"
TEST_TARGET_URL_WITH_INVALID_OPTION = "https://www.google.com?test={test}"

START_INDEX = 1
END_INDEX = 10

START_DATE = "20211001"
END_DATE = "20211020"

START_DATETIME = "2021-10-01 00:00:00"
END_DATETIME = "20211020 00:00:00"

TEST_ITERATOR_LIST = [range(1, 10)]
TEST_ITERATOR_DICT = {"index_1", 1, "index_2", 2, "index_3", 3}


class TestURLs:

    def test_generate(self):
        url = URL(TEST_TARGET_URL)
        assert url.base_url == TEST_TARGET_URL, "The URL value and target url is not the same."


    def test_generate_with_rule(self):
        index_urls = URL(TEST_TARGET_URL_WITH_INDEX, START_INDEX, END_INDEX)
        # Check for the amounts of setting and the return value of URL.
        assert len(index_urls) == len(range(START_INDEX, END_INDEX)), "The amounts of index range and URL should be the same."
        # Check the format of URLs which be return from URL object.
        index_options = [f"index={i}" for i in range(START_INDEX, END_INDEX)]
        index_urls_options = []
        for _url in index_urls:
            search_result = TestURLs._get_url_option(url=_url, option_format=r"index=[0-9]")
            index_urls_options.append(search_result.group(0))
            assert search_result.group(0) in index_options, "The URL value should only be generated by the passing option."
        assert set(index_urls_options) == set(index_options), "Index options list and URL list should be the same."

        date_urls = URL(TEST_TARGET_URL_WITH_DATE, START_DATE, END_DATE, "yyyymmdd")
        d1, d2 = TestURLs._get_yyyymmdd_date_objs(START_DATE, END_DATE)
        diff_days = (d2 - d1).days
        assert len(date_urls) == diff_days, "The return value amount of URL should be the same with period days between target 2 dates."
        all_days = [(d1 + timedelta(days=i)).isoformat() for i in range(diff_days + 1)]
        all_days_arguments = [f"date={_day.replace('-', '')}" for _day in all_days]
        date_urls_options = []
        for _url in date_urls:
            search_result = TestURLs._get_url_option(url=_url, option_format=r"index=[0-9]")
            date_urls_options.append(search_result.group(0))
            assert search_result.group(0) in all_days_arguments, "The URL value should only be generated by the passing option."
        assert set(date_urls_options) == set(all_days_arguments), "Date options list and URL list should be the same."

        datetime_urls = URL(TEST_TARGET_URL_WITH_DATETIME, "20211001", "20211020")
        assert len(datetime_urls), ""

        iterator_urls = URL(TEST_TARGET_URL_WITH_ITERATOR, TEST_ITERATOR_LIST)
        assert len(iterator_urls) == len(TEST_ITERATOR_LIST), ""

        iterator_urls = URL(TEST_TARGET_URL_WITH_ITERATOR, TEST_ITERATOR_DICT)
        assert len(iterator_urls) == len(TEST_ITERATOR_DICT), ""


    @staticmethod
    def _get_url_options(urls, option_format):
        urls_options = []
        for _url in urls:
            parameters = str(_url).split("?")
            argument = parameters[-1]
            search_result = re.search(option_format, argument)
            urls_options.append(search_result.group(0))


    @staticmethod
    def _get_url_option(url, option_format):
        parameters = str(url).split("?")
        argument = parameters[-1]
        search_result = re.search(option_format, argument)
        return search_result

    @staticmethod
    def _get_yyyymmdd_date_objs(date1, date2):
        s_year = int(date1[:4])
        s_month = int(date1[4:6])
        s_day = int(date1[6:])
        e_year = int(date2[:4])
        e_month = int(date2[4:6])
        e_day = int(date2[6:])
        d1 = date(s_year, s_month, s_day)
        d2 = date(e_year, e_month, e_day)
        return d1, d2

